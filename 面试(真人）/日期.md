# 日期

## 4/13

### 豪猪

* 预编译： 少使用很多选择器，写起来方便，混入；兼容性
* node require： 去查询node_modules 然后找到main字段的文件
* 代码评审: 重复代码；
* css选择器: important, 内联, id, (class,属性,伪类focus), (元素标签,伪元素first after)
[css选择器优先级顺序](https://www.cnblogs.com/y1114078559/p/12663926.html)

* flex: 1 表示 1 1 auto
grow: 有多余占据; shrink：不够就缩小； basis：计算项目是否有多余空间，默认项目本身大小
* 函数式编程:把运算过程尽量写成一系列嵌套的函数调用

MongoDB查询 非关系型数据库(结构不固定，减少时间和空间的开销，不适合持久存储海量数据)
线程进程 资源分配最小单位， 线程 cpu调度最小单位 （火车车厢[线程和进程的区别是什么？](https://www.zhihu.com/question/25532384)

设计模式

洋葱模型

```js
app.use(async (ctx, next) => {
    console.log(2)
    await next();
    console.log(2)
})
```

什么时候不用key
技术专家
新技术 vite 微服务

[MVC，MVP 和 MVVM 的图示](http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)
MVC view （传达指令）=> controller (完成业务逻辑，改变model状态)=> model （新数据发送到view，用户反馈）=>view
视图（View）：用户界面。
控制器（Controller）：业务逻辑
模型（Model）：数据保存
MVP
各部分之间的通信，都是双向的。
View 与 Model 不发生联系，都通过 Presenter 传递。
mvvm Model-View-ViewModel
MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致
唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel

render

### 咏柳科技

koa中间件 去了解koa技术点
代码自动打包（上线
技术性的东西(有个模块组合，用了其他插件都达不到效果，去找相关的竞品 没有关于vue框架的，然后就要去用jqurey版本的来进行源代码的修改)

#### 虚拟dom如何查找不一样

[前端面试必备技巧（二）重难点梳理](https://juejin.cn/post/6844904152850497544)
虚拟 DOM 的实现原理主要包括以下 3 部分：

用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；
diff 算法 — 比较两棵虚拟 DOM 树的差异；
pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。
[深入剖析：Vue核心之虚拟DOM](https://juejin.cn/post/6844903895467032589)
为什么引入虚拟dom： 因为每一次对dom进行操作都会导致马上执行（有些layout可能就好几次无用的）
[Vue 3.0 diff 算法及原理](https://mp.weixin.qq.com/s?src=11&timestamp=1618323006&ver=3006&signature=JCzWfOIKNAK-eWPwBhWoRQUbq0Ra4adlBobwpIJckwGsjOLk0MBM0HvduMIcZM2cqo5idP9*RPu1Fu2Qzc7B0u8kJ6Lp8VmgWZdaLC9FPNKxvebcfS0ydzGpRcdEO8Ii&new=1)
数据代理 object 和array
vue3 跟vue2的区别

如何监听
对数组的方法进行劫持，运行劫持的方法去通知dep（数据变化

新技术：deno, vue3.0, vite
自己想做什么：专门的团队精进一下后端的技能和知识， 摆弄服务端，跟前端一起用最前沿的东西来攻克难关 ； 后续可能还是想往技术上靠
nextTick
[vue首屏加载优化](https://juejin.cn/post/6844904122747977736)
[Webpack性能优化](https://juejin.cn/post/6844904088233050126)

微信小程序性能优化

1. 分包
2. 不要频繁表用setData方法

## 4/14

### 惠众信用评级

跨域和同源
跨域：两个不同源的网站之间可以相互请求数据的。这就需要使用到跨域
跨域资源共享(CORS)： 服务器允许跨域的代码
跨域行为是浏览器行为，响应是回来了的, 只是浏览器安全机制做了限制, 对于跨域响应内容进行了忽略

xss攻击：用户输入的数据被当成脚本进行运行
防御： 对于用户输入的 引号，尖括号，斜杆进行转义
富文本用白名单来过滤 标签或者标签属性

CSRF攻击：跨站请求伪造，诱导用户去请求
防御： referer过滤，防止第三方访问用户cookie， 请求附带token信息（session里面

session 和cookie区别： 前者存到数据库，后者在浏览器
[COOKIE和SESSION有什么区别？](https://www.zhihu.com/question/19786827/answer/21643186)

1. session 在服务器端，cookie 在客户端（浏览器）
2. session 默认被存在在服务器的一个文件里（不是内存）
3. session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）
4. session 可以放在 文件、数据库、或内存中都可以。
5. 用户验证这种场合一般会用 session

ajax原理
[Ajax原理一篇就够了](https://segmentfault.com/a/1190000017396192)

1. 创建XMLHttpRequest，调用open方法，并指定请求路径（指定请求类型）
2. 发送请求 send
3. 监听readyState的回调（4表示完成， 0表示初始化，1表示启动open， 2表示 send， 3表示接受部分
4. 200 成功， 300重定向，400请求错误， 500服务器问题

部分重要状态： 200 ，301 永久重定向，302暂时 304服务端资源未改变从本地读取 400 请求中有错误语法 401认证失败，403 拒绝访问资源 404

原型链
每个函数都有原型属性prototype，最终都指向object，然后每个对象都有__proto__属性，指向他的原型，一直通过这个链接起来的关系链叫原型链
[轻松理解JS 原型原型链](https://juejin.cn/post/6844903989088092174)

跨域 option
是浏览器自动发起的，服务器返回允许的方法

RESTful API 规范

get 获取信息
post 新建信息
put 修改信息
delete 删除信息

分段传输

### 潘帕斯

组件开发
nextTick
中间件
二维有序变一维有序
aaabbbcc记录数量

## 4/15

### 天目传媒

setTimeout setInterval 在事件队列中不同点
大文件上传

### 指令集

SHA256 sha加密
nextTick
视图更新 改变背景 只更新一次
调试： 1.抓包 2.快照（判断是否有内存泄漏 3.硬调
$set
typeof function class
class 和继承 和原型链
工程化 打印package.json
babel 配置
[理解webpack4.splitChunks](https://www.cnblogs.com/kwzm/p/10314438.html)

[Babel 配置用法解析](https://www.cnblogs.com/bai1218/p/12392180.html)
babel插件和babel预设是babel配置的两个主要模块，所以我就放在一起说了。

```js
/* babel.config.js */

module.exports = {
  presets: [
    "@babel/preset-env" // 比下面来的强大（预设包）有各种处理
  ],
  plugins: [
    "@babel/plugin-transform-arrow-functions" // 处理箭头函数
  ]
},
presets: [
    [
      "@babel/preset-env", {
        // 什么环境需要转化
        'targets': {
          'browsers': ['ie >= 8', 'iOS 7'] // 支持ie8，直接使用iOS浏览器版本7
        }
      }
    ]
],
```

然后我们只需要在入口文件顶部引入 @babel/polyfill 就可以使用新增的API了

babel默认转义的是js语法不会转换新的api，所以需要用 @babel/polyfill
但是不会所有的新api都要使用，在 presets里面写按需引入**useBuiltIns**属性来按需引入polyfill

```js
/* babel.config.js */

module.exports = {
  presets: [
    [
      "@babel/preset-env", {
        "modules": false,
        "useBuiltIns": "entry",
        'targets': {
          'browsers': ['ie >= 8', 'iOS 7'] // 支持ie8，直接使用iOS浏览器版本7
        }
      }
    ]
  ],
  plugins: [
  ]
}
```

### 微易科技保险师

服务器出问题 (心跳，pm2)
前端代码自动化部署

* computed原理
[computed原理](https://blog.csdn.net/qq_21859119/article/details/83001851)
  
  1. 获取computed定义的方法作为自己的getter方法
  2. 创建watcher 和dep

> watcher实例化 dep并向dep.subs添加订阅者， dep通过notify遍历dep.subs通知watcher

tress shaking原理
[tree shaking 及其工作原理](https://segmentfault.com/a/1190000038962700)

* es module 引入静态分析，编译时引用（判断加载了哪些模块）
* 静态分析程序流，判断哪些模块和变量未被使用或引用，进而删除对应代码

commonjs 和 es6引入的区别

1、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
2、CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
3、CommonJs 是单个值导出，ES6 Module可以导出多个
4、CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层
5、CommonJs 的 this 是当前模块，ES6 Module的 this 是 undefined

### 乌鸫

介绍项目： 偏向于可视化的设备选型，在web界面输入自己场景信息内容并配置最终导出可行性的图纸方案和物料清单，服务于售前和技服

RequireJS 和seajs
[SeaJS与RequireJS最大的区别](https://www.douban.com/note/283566440/)
前者是模块预执行 后者是懒执行
SeaJS只会在真正需要使用(依赖)模块时才执行该模块，所以更合适
axios

## 4/16

### 豪猪二面 10:30

* jsonp 跨域
协议、域名、端口三者中任意一个
响应数据被浏览器给拦截了，
access control allow origin

隐患： 主要是属于csrf(cross site request forgery)数据劫持，伪造一个script标签，引用点击将发挥的东西发送到自己服务器上
[http请求头中Referer的含义和作用](https://blog.csdn.net/shenqueying/article/details/79426884)
解决： referer过滤; 按照content-type为 application/json

* event bus
[VUE中 eventbus 的原理](https://blog.csdn.net/qq_45149256/article/details/112129291?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242)

即这个vue中有个对象，`$on`就是将事件绑定到callback对象上，`$emit`的时候就去找这个对象查询是否有这个方法，有的话就执行该方法

* 代理原理 vue代理
启动一个同源的服务进行接口代理 (实际使用node运行一个服务器，将请求发送给自己启动的服务器，再由服务器转发给后台服务器)

* v8垃圾回收原理(谷歌浏览器特有的垃圾回收装置)
    [V8引擎垃圾回收机制分析](https://blog.csdn.net/weixin_41376400/article/details/106076661)
    上面更加详细
    [V8及其垃圾回收机制](https://blog.csdn.net/weixin_45449964/article/details/113819978)
    v8分为新生代对象和老生代对象
    前者存活时间较短; 后者存活时间较长的对象

    回收策略

  * 前者 内存空间一分为二,为to和from区域,先生代会先存储在from区域,先处理from区域(用标记清除法),清除完成后,from空间存活复制到to空间然后释放from区域内容,并将to和from空间进行交换
    晋升: 一轮GC处理后存活的新生代对象会转边成老生代对象,来防止新生代对象内存空间占满的情况(多次交换 空间还是存在 5次)
  * 后者 主要还是标记清除法, 当晋升导致空间不足时会使用标记整理碎片化空间(增量标记方式对对象进行标记): 增量标记在标记过程不是连贯的, 将标记的过程拆分为多个小的过程(主要考虑对象过多情况标记太多导致卡顿)

### 兴业数字金融服务 14:00

下拉框 select标签
object.length 为undefined
padding不能有负值

### 富通天下 19：30

没问技术

## 4/17

### 指令集二面

业务讨论

## 4/19 周一

### 超视距 14:00

vue源码
koa和express （继续中间件）
mpvue的坑
css3 动画单词

### 恒生电子 19:00

web界面截图（截图api
节流 60Hz，1000/60 所以约等于16ms

vue-router 源码(还没看。)
[vue-router的使用及实现原理](https://blog.csdn.net/caoxinhui521/article/details/77688512/?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242)

* 路由hash和history
    前者：onhashchange
    后者：pushState() 和 replaceState()
    优势：
     1. 设置的新url可以与当前url同源的任意url；后者当前url同文档url
     2. 设置的新url可以跟当前一模一样，后者不一样才会触发change
     3. stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串
    劣势：部分链接后端没有配合会返回404

订阅转发
mutation action 是否通过mutation
事件队列（近一年 一个月

前端的时候有做过什么优化策略

1. 减少http请求：雪碧图；小图用base64
2. css放头部
3. 开启gzip
4. 大的第三方包用cdn
5. webpack优化

## 4/20 周二

### 爱库存 10:00

promise 和async (eɪˈsɪŋk)
[async 函数的含义和用法](http://www.ruanyifeng.com/blog/2015/05/async.html)

网络协议
七层：物理层；数据链路层；网络层；传输层（TCP，UDP），会话层；表示层；应用层
Ip 网关 物理地址

### 指令集 hr面 14:00

优点：
缺点：
业务介绍：

### 朗新科技 15:00

复试沟通 18576071272
网页性能
service work
$nextTick
$emit
$set

* 状态码
204 返回信息内容为空
302 暂时的重定向  301永久重定向 304 资源有缓存
400请求写的有问题； 401未授权； 403禁止访问 ； 405资源被禁止
500 服务器有问题； 503 负载或者停机无法处理

### 涂鸦智能 20:00

状态码
事件机制
csrf攻击

## 4/21 周三

### 业金数金 10:00
