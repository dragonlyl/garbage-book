# 文档

## url

[17K star 仓库，解决 90% 的大厂基础面试题](https://juejin.cn/post/6947860760840110088)

## 数据类型

两种类型: 基本类型和对象类型

undefined , null, boolean, string, number, symbol, bigint

function object (array, map, set, **math ,regexp**)

存储位置 ,  **前者 存放在栈 ,后者存放在堆里面**

对于对象是引用地址还是存储在栈里面

1/0 Infinity
1/'s' NaN (非数字)
大数相加: 用 bigInt

## 类型判断

### typeof 对于null 为object ,对 function 为function

### instanceof

主要通过查找原型链来确定
**通过 对象的 `val.__proto__ === target.prototype`**

```js
// 只有函数有prototype, 所有对象都用 `__proto__`
function myInstanceof (val, target) {
    let pro = val.__proto__;
    let o = target.prototype;
    while (pro) {
        if (pro === o) {
            return true;   
        }
        console.log(pro);
        pro = pro.__proto__
    }
    return false
}

let obj = {};
myInstanceof(obj, Object);
```

### constructor 用来查找构造函数

[理解Javascript_11_constructor实现原理](https://www.jb51.net/article/25027.htm)

```js
let arr = [];
arr.constructor === Array; // true
arr instanceof Array; // true
// 但是下面这个跟Object 想比也是true,前者是false

Object.constructor === Function;
```

> 个人: Object 跟 {} 是不一样的, 前者是构造函数, 后者是对象使用 typeof Object 是 'function'  后者是 typeof {} 是 'object'

constructor 跟prototype的联系

foo.prototype.constructor === foo; // 原型的构造函数指向自己
原理: **使用constructor的原理 是 调用原型上的constructor函数找到构造函数**

// 下面写法之前有误
不应该是 [].prototype.shift 而是 Array.prototype.shift
因为 [].shift 实际上 等效于 `[].__proto__.shift === Array.prototype.shift`

### Object.prototype.toString.call()

### isArray,  isNumber, isNaN

### isPrototypeOf

定义在Object.prototype上,用来检测是否存在xx的原型链上

用法 `prototypeObject.isPrototypeOf(object);`

```js
var f = function () {}  //定义函数
var o = new f(); 
f.prototype.isPrototypeOf(o);
console.log(Function.prototype.isPrototypeOf(Object));  //返回true
console.log(Object.prototype.isPrototypeOf(Function));  //返回true
```

```js
function Foo(){};
let foo = new Foo;
// 手写new
function myNew () {
    let O = [].shift.call(arguments);
    // 创建空对象, 将该对象的proto 指向 构造函数的原型上
    let obj = Object.create(O.prototype);
    // 绑定this, 是该对象能访问到构造函数中的属性(将该对象作为this的上下文)
    let ret = O.call(obj, ...arguments)
    // 优先返回构造函数返回的对象
    return typeof ret === 'object' : ret : obj;
}
// 手写call
Function.prototype.myCall = function (target) {
    if (typeof this !== 'function') {
        throw new Error('type error')
    }
    let arg = [...arguments].slice(1)
    target.fn = this;
    // 将函数处于对象上执行 (如果fn中有添加新属性,那么target也会添加上)
    let ret = target.fn(...arg);
    delete target.fn;
    return ret;
}
let obj = {};
foo.myCall(obj);

// 所以这也能够解释  foo 跟 new foo的区别
var val = 111;
function fun(){
    alert(this.val)
}
// 这里打印 111
fun()
// 这里打印 undefined ,因为 用new 创建的对象没有 val 属性
var aaa = new fun()
```

## 类型转换

### 强制类型转换

通过 Number 或者 toString进行转换
**转数字 ,null 为0 ; undefined 为 NaN, symbol 报错**

### 隐式类型转换

[toString方法和valueOf方法以及Symbol.toPrimitive方法的学习](https://segmentfault.com/a/1190000016300245)

普通数据类型 valueOf 跟原值一样, toString 是转换成对应字符串
undefined 和 null 除外

对象 先用 Symbol.toPrimitive, 然后在调用valueOf 转化 ,之后调用toString
有运算操作符会先调用 valueOf ,如果只是用于字符串展示会先调用 toString

优先级: Symbol.toPrimitive > valueOf > toString

```js
let obj = {
    // 有三种模式, number string 和default
    [Symbol.toPrimitive](hint) {
        if (hint === 'number') {
            return 42;
        }
        if (hint == "string"){
            return "hello";
        }
        return null;
    },
    toString: function() { 
        return 4
    },
    valueOf: function() { 
        return 5
    },
};
```

[] == false  // []先转换成 空字符串 再转换成数字

## this

## 闭包

函数能访问外部的变量

## 继承(继承属性 方法)

es6之前继承

### [面向对象之公有、私有、静态属性和方法详解](https://www.jb51.net/article/64278.htm)

### 函数的公有属性和公有方法

要想调用必须实例化

```js
function User(name,age){
  this.name = name;//公有属性
  this.age = age;
}
User.prototype.getName = function(){//公有方法
  return this.name;
}
var user = new User('fire子海',26);
console.log(user.getName());//output:fire子海
// User里面的属性和方法不能不能直接调用,需要通过 new创建的对象进行访问
// 打印user {this.name = 'fire子海'; ...}
```

### 函数的私有属性和私有方法

即只有函数内部才能访问,也无法通过创建对象方法

```js
function User (name, age) {
    var name = name;
    var age = age;
    function alertAge () {
        alert (age);
    }
    alertAge();
}
var user = new User('fire子海',26);
// 打印user 就是  User {}
```

### 静态属性和方法

1. 使用对象本身调用,不能使用this调用静态方法和属性
2. 对象实例不能调用,只能调用实例自身的静态属性
3. 静态方法无法调用公有属性,公有方法,私有方法,私有属性,特权方法,原型属性

```js
function User(){}
User.age = 26;//静态属性
User.myname = 'fire子海';
User.getName =function(){//静态方法
  
  return this.myname;//如果这里使用this.name，返回的将是User，所有改用了myname，
}
console.log(User.getName());//output:fire子海
```

### 特权方法

类似于闭包,即能访问到内部的私有属性

```js
function User(name,age){
    var name = name;//私有属性
    var age = age;
    this.getName = function(){ //特权方法
        return name;//私有属性和方法不能使用this调用
    }
}
var user = new User('fire子海',26);
console.log(user.getName());//output:fire子海
```