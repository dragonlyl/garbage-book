# 手写代码

## iterator

## 双向数据绑定

## call

```js
Function.prototype.myCall = function () {
    let ctx = [...arguments].shift() || window;
    ctx.fn = this;
    let arg = [...arguments].slice(1);
    let result = ctx.fn(...arg);
    delete ctx.fn
    return result

}
let obj = {x: 1};
function tst(a) {console.log(this.x, a)};
tst.myCall(obj, 2);
```

```js
Function.prototype.myBind = function () {
    let obj = [].slice.call(arguments);
    let arg = arguments;
    let fn = this;
    return function fn1() => {
        if(this instanceof fn) {
            return new fn1()
        }
        this.apply(obj, [...arg, ...arguments])
    }
}
```

## compose(6/7;)

```js
// 用法如下:
function fn1(x) {
  return x + 1;
}
function fn2(x) {
  return x + 2;
}
function fn3(x) {
  return x + 3;
}
function fn4(x) {
  return x + 4;
}
const a = compose(fn1, fn2, fn3, fn4);
console.log(a(1)); // 1+4+3+2+1=11

function compose() {
    let arg = [].slice.call(arguments);
    return (x) => {
        return arg.reduceRight((pre, cur) => cur(pre), x);
    }
}

```

## setTimeout 实现setInterval

## 发布订阅模式

```js
class EventEmitter {
    constructor () {
        this.events = {}
    }

    on (name, fn) {
        if (!this.events[name]) {
            this.events[name] = []
        }
        this.events[name].push(fn);
    }
    emit (name, ...value) {
        if (!this.events[name]) {
            return;
        };
        this.events[name].forEach(v => {
            v.apply(this, value)
        });
    }
    off (name, fn) {
        if (!this.events[name]) {
            return;
        };
        this.events[name] = this.events[name].filter(v => {
            return v !== fn
        }); 
    }
    once(name, fn) {
        function packageFn() {
            fn(...arguments);
            this.off(name, packageFn)
        }
        this.on(name, packageFn)
    }
}
let event1 = new EventEmitter();
event1.on('12', (val) => {console.log(11, val)})
event1.once('12', (val) => {console.log(22, val)})
event1.emit('12', 33);
event1.emit('12', 33)
```

## 数组去重

```js
[...new Set(arr)]
```

## 降维度

```js
console.log(flatter([1, 2, [1, [2, 3, [4, 5, [6]]]]]));
// 递归

function flatter(arr) {
    return arr.reduce((pre, cur) => {
        Array.isArray(cur) ? pre.concat(flatter(cur)) : pre.concat(cur)
    }, [])
}

function flatter (arr) {
    while (arr.some(val => Array.isArray(val))) {
        arr = [].concat(...arr);
    }
    return arr;
}
```

## 继承es5(寄生组合继承)

```js
function Parent (name) {
    this.name = name;
    this.inner = function () {
        console.log('inner' + this.name)
    }
}
Parent.prototype.outer = function () {
    console.log('outer' + this.name)
}
function Child (name) {
    A.call(this);
    this.name = name
}
Child.prototype = Object.create(Parent.prototype, {
    constructor: {
        value: Child,
        writable: true,
        enumerable: false,
        configurable: false
    }
})
let child = new Child('Dragon');
child.inner();
child.outer();
```

## new

```js
let myCreate = function () {
    let fn = [].shift.call(arguments);
    // 创建空对象,并指向构造函数的原型
    let obj = Object.create(fn.prototype);
    // 绑定this 执行 ,同时执行构造函数
    let ret = fn.call(obj, ...arguments);
    return ret instanceof Object ? ret : obj;
}
function Person(name, age) {
    this.name = name;
    this.age = age;
}
Person.prototype.say = function() {
    console.log(this.age);
};
let p1 = myNew(Person, "lihua", 18);
console.log(p1.name);
console.log(p1);
p1.say();
```
## bind call apply

```js
Function.prototype.myCall = function (obj) {
    if (typeof this !== 'function') {
        throw new TypeError('no function ')
    }
    let fn = this || window;
    let symbol = Symbol();
    let arg = [...arguments].slice(1);
    obj[symbol] = fn;
    let result = obj.fn(...arg);
    delete obj[symbol];
    return result;
}
Function.prototype.myApply = function (context) {
    if (typeof this !== 'function') {
        throw new TypeError('not function')
    }
    let _this = this || window;
    let fn = Symbol();
    context[fn] = _this;
    let result;
    if (arguments[1]) {
        result = context[fn](...arguments[1])
    } else {
        result = context[fn]()
    }
    delete context[fn];
    return result;
}
Function.prototype.myBind = function () {
    let context = [].shift.call(arguments) || window;
    let arg = arguments;
    let fn = this;
    return function fn1 () {
        return this instanceof fn1 ? new fn(...arguments) : fn.apply(context, arg.concat(...arguments))
    }
}

let obj = {t: '33'}
function tt(a,bb) {
    console.log(this.t, a,bb);
}
tt(12,22);
tt.myApply(obj,[12,33])
```