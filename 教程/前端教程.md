# 教程

## 前端技能模型

编程能力    架构能力     工程能力
难写不出来  大写不出来    组织

## 学习方法

整理法: 
追溯法

## Unicode

block

```js
// 打印出 0- 128的 Unicode
for (let i = 0; i < 128; i++) {
    console.log(String,fromCharCode(i));
}
```

## taro

## jest

### 为什么需要

[前端测试之Jest深入浅出](https://juejin.cn/post/6844904196244766728)

1. 更快的发现bug
2. 比注释效果更好 (观察输入输出)
3. 利于重构 (在测试代码如果比较完善, 直接将重构代码跑case)
4. 更深的理解业务流程,让代码更完善

### 概念内容

#### TDD 和 BDD

##### TDD 与单元测试

1. TDD `Test Driven Development`, 测试驱动开发.  先编写测试代码后为了所有测试代码都通过,编写逻辑代码

2. 单元测试:指对软件中最小可测试单元进行检查和验证. 单元可以理解成独立的模块文件,(TDD一般指这个)

##### BDD 与集成测试

1. BDD `Behavior Driven Development`, 行为驱动开发. 先...然后以所有业务逻辑按照结果职执行为目的编写测试代码

2. 集成测试 `Integration Testing`, 对软件所有模块按照设计要求组装成系统后,进行检查和验证 (BDD一般指这个)

### Jest 使用(待)

// 待手动尝试(https://juejin.cn/post/6844904196244766728#heading-11)

#### Jest matchers(待) 详细看所有的

expected 期望的函数结果 toBe 判断类型(不能比较对象相等)
toEqual 

```js
test('twoSum([2, 3, 4, 6], 10)', () => {
    expect(twoSum([2, 3, 4, 6], 10)).toBe([2, 3])
})  // 无法比较 (数组比较不出来)
test('twoSum([2, 3, 4, 6], 10)', () => {
    expect(twoSum([2, 3, 4, 6], 10)).toEqual([2, 3])
}) // 可以比较
```

## ts-jest(jest中)

### 简介

对于ts测试中,对ts类型就行检查,这时候`@babel/preset-typescript`并不能帮你完成这样的工作，你就需要使用`ts-jest`来进行typescript的支持(直接利用tsc的编译能力，不需要使用babel)

#### 对比Babel7 or TypeScript(待)

可以查看 是ts-jest 还是 babel的对比  [Babel7 or TypeScript](https://kulshekhar.github.io/ts-jest/docs/babel7-or-ts/)

### url

[在Jest中使用ts-jest](https://juejin.cn/post/6982401460130545672)

## 建议查看(重要)

[从0到1开发一个开源项目(TS + ESlint + Jest + TravisCI)](https://juejin.cn/post/6844904063457312781)

### TravisCI (前端持续集成 自动化部署) (重要)
## GitHook 工具

### 链接

[GitHook 工具 —— husky（格式化代码）](https://juejin.cn/post/6947200436101185566)
### 简介

githook工具 格式化代码 (保持代码可读性,统一团队成员代码)

1. husky：Git hooks 工具
对git执行的一些命令，通过对应的hooks钩子触发，执行自定义的脚本程序

2. lint-staged：检测文件插件
只检测git add . 中暂存区的文件，对过滤出的文件执行脚本

3. eslint：插件化JavaScript代码检测工具
Js编码规范，检测并提示错误或警告信息

4. prettier：代码格式化工具
代码风格管理，更好的代码风格效果

5. editorconfig：文件代码规范
保持多人开发一致编码样式

6. commitlint：代码提交检测
检测git commit 内容是否符合定义的规范

7. commitizen：代码提交内容标准化
提示定义输入标准的git commit 内容

### husky

hooks
git hooks 工具 ,对git 执行的命令,通过触发对应hooks钩子触发

```json
// 在package.json 中添加以下代码
"husky": {
  "hooks": {
      // 提交commit时触发
    "pre-commit": "lint-staged",
      // 检测commit的message时触发
    "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
  }
}

```

### lint-staged

linters

```json
// 在package.json 中添加以下代码
"scripts": {
    "lint-staged": "lint-staged",
}

"lint-staged": {
    // 匹配暂存区所有的js，vue文件，并执行命令
  "*.{js,vue,jsx,tsx}": [
    "prettier --write",
    "eslint --cache --fix",
    "git add"
  ]
}
```

### 工程代码

[从0搭建Vite + Vue3 + Element-Plus + Vue-Router + ESLint + husky + lint-staged](https://juejin.cn/post/6949138186886971429)

## bash(shell)

### url

[mac终端bash、zsh、oh-my-zsh最实用教程](https://juejin.cn/post/6844904001251573773)
[实用的 bash 自定义脚本，快速提效工作流程](https://juejin.cn/post/6844904185599623175)
[10分钟入门Shell脚本编程](https://juejin.cn/post/6844903553119748109)

## commander

### 链接

[脚手架系列-commander](https://juejin.cn/post/6959750919491682318)

### 介绍

commander // 命令行文字提示
const program = require('commander')
<!-- program.option('').parse(process.argv) -->
chalk
const { yellow } = chalk //  yellow('命令行出现黄色的字')
process.argv
[process.argv](http://nodejs.cn/api/process/process_argv.html)
cross-spawn  const spawn = require('cross-spawn')
sync // 同步
async // 异步
str.split(/\s/g) // 拆分格式

spawn.sync(cmd, ...arg, option)
/\s/ // 用来匹配空格键
[正则图形化界面]https://regexper.com/

## cdn

## webpack-merge

## formily

## npm link

要运行的程序使用 `npm link` (本地仓库挂到全局上)

要使用该工程使用该包 `npm link xx` // xx 为package.json的 name 字段

卸载  npm unlink xx // 使用的目录
npm unlink // 引出的目录


## 前端工程化

### 介绍

[「前端工程化」该怎么理解？](https://segmentfault.com/a/1190000023943703)

前端框架：插件化（jQuery） -> 模块化（RequireJS） -> 组件化（React）
构建工具：任务化（grunt/gulp） -> 系统化（webpack）
CI/CD：工具化（Jenkins） -> 自动化（Web Hook） # 指持续集成 和持续交付/部署

从开发 测试 构建 部署 监控各个要点


## 待提升

计算的本质

haskell

rrweb (用户出bug的)

前端 def部署 和bus接入

web体系
## git 使用 

[git alias](https://github.com/ohmyzsh/ohmyzsh/blob/master/plugins/git/git.plugin.zsh)

`gst` git status
`gaa` git add -all
`gcmsg`  git commit -m ''
`gp`  git push
`gl`  git pull
`gup`  git pull -rebase // 不会有 merge branch 'xx' of .. 这些文字
`gb`  git branch
`gco`  git checkout 

yarn add package-name@1.2

“5.0.3”表示安装指定的5.0.3版本
“～5.0.3”表示安装5.0.X中最新的版本
“^5.0.3”表示安装5.X.X中最新的版本。

[changelog](https://keepachangelog.com/en/1.0.0/)

[npm发布scope](https://segmentfault.com/a/1190000017234785) // 下面的连接也可以看

## lerna

### 仓库地址

[lerna-repo](https://github.com/dragonlyl/lerna-repo)

[lerna管理前端模块最佳实践](https://juejin.cn/post/6844903568751722509) // 基本知识内容介绍
[基于 Lerna 管理 packages 的 Monorepo 项目最佳实践](https://juejin.cn/post/6844903911095025678)
monorepo(相关package放在一个仓库里管理)和multirepo (每一个package都单独用个仓库管理)
利弊: 前者 多元化发展(有各自的构建工具,依赖管理策略,单元测试), 后者集中管理,减少项目中差异带来的沟通成本

``` js
lerna add chalk                                           // 为所有 package 增加 chalk 模块
lerna add semver --scope @mo-demo/cli-shared-utils        // 为 @mo-demo/cli-shared-utils 增加 semver 模块
lerna add @mo-demo/cli-shared-utils --scope @mo-demo/cli  // 增加内部模块之间的依赖
```

`lerna bootstrap --hoist` // 不同package的依赖提到工程根目录下

或者在lerna.json 里面进行配置 (通过 不用写 --hoist 参数)

```json
{
  "packages": [
    "packages/*"
  ],
  "command": {
    "bootstrap": {
      "hoist": true
    }
  },
  "version": "0.0.1-alpha.0"
}

```

`lerna clean` // 清理所有的依赖


## git subtree

[用 Git Subtree 在多个 Git 项目间双向同步子项目，附简明使用手册](https://segmentfault.com/a/1190000003969060?utm_source=sf-similar-article)

## lint

通过将代码解析成 `抽象语法树`, 遍历 抽象语法树并通过 预设规则做判断和修改,再将新的抽象语法树转换成正确代码

可阅读`babel`源码或`eslint`源码了解其工作原理。

### eslint 源码

查看到 有process 内容

## process

存在 node 全局对象上,不需要 require() 加载, 主要做如下
1. 获取进程信息 (资源使用 运行环境 运行状态)
2. 执行进程操作 (监听事件 调度任务 发出警告)

[Node.js process 模块解读](https://juejin.cn/post/6844903614784225287)

### 资源使用

`process.memoryUsage()`

```js
process.memoryUsage())

{ rss: 21848064, // (常驻内存)
  heapTotal: 7159808,
  heapUsed: 4431688,
  external: 8224 // C++对象(与V8管理的js对象绑定), 比如Buffer的使用
}

Buffer.allocUnsafe(1024 * 1024 * 1000) // 会发现 external变多

process.cpuUsage() // 获取cup
```

### 运行环境 (运行目录,node环境,cup架构,用户环境,系统平台)

`process.cwd()` // 目录
`process.version`  // node 版本 // versions获取更多内容
`process.env.NODE_ENV` // 获取 用户环境参数
`process.platform` // 系统平台
execPath // 执行目录
mainModule // 判断是否为主文件
pid

### 监听事件

process是EventEmiiter的实例对象，因此可以使用process.on('eventName', () => {})来监听事件。
常用的事件类型分两种：

进程状态 比如：beforeExit、exit、uncaughtException、message
信号事件 比如：SIGTERM、SIGKILL、SIGUSR1

beforeExit与exit的区别有两方面：

beforeExit里面可以执行异步代码、exit只能是同步代码
手动调用process.exit()或者触发uncaptException导致进程退出不会触发beforeExit事件、exit事件会触发。

因此下面的代码console都不会被执行

```js
process.on('beforeExit', function(code) {
  console.log('before exit: '+ code);
});
process.on('exit', function(code) {
  setTimeout(function() {
    console.log('exit: ' + code);
  }, 0);
});
a.b();
```


[前端万字面经——进阶篇](https://juejin.cn/post/6993141036600000548)
[山月行博客](https://shanyue.tech/post/ts-tips.html#%E5%8F%82%E8%80%83)
[掘金 bash](https://juejin.cn/search?utm_source=gold_browser_extension&query=bash)
[有赞商赋周刊](https://yzfun.club/week/1)
[尤雨溪国外教程：亲手带你写个简易版的Vue！](https://juejin.cn/post/6992018709439053837)
[掘金 web体系](https://juejin.cn/search?utm_source=gold_browser_extension&query=web%E4%BD%93%E7%B3%BB)
[Web 前端知识体系目录大纲（足有 400 行）](https://juejin.cn/post/6855559358495850510#heading-8)
[Lerna --多包存储管理工具（一）](https://segmentfault.com/a/1190000023954051)
[掘金 lerna](https://juejin.cn/search?utm_source=gold_browser_extension&query=lerna)
[基于 Lerna 管理 packages 的 Monorepo 项目最佳实践](https://juejin.cn/post/6844903911095025678)
[掘金 lint-stage](https://juejin.cn/search?utm_source=gold_browser_extension&query=lint-stage)
[一键格式化代码带来的快感 | 你还在为每个项目配置Stylelint和Eslint吗](https://juejin.cn/post/6933009968710811661)
[使用 husky、commitlint 和 lint-staged 来构建你的前端工作流（vue、react、dva）](https://juejin.cn/post/6844904048525574152#heading-20)
[GitHook 工具 —— husky（格式化代码）](https://juejin.cn/post/6947200436101185566#heading-4)
[前端框架系列之（eslint源码解析）](https://www.jianshu.com/p/94edc8e59b6d)
[面试官问你关于node的那些事（进阶篇）](https://juejin.cn/post/6844904177466867726#heading-8)
[一篇文章构建你的 NodeJS 知识体系](https://juejin.cn/post/6844903767926636558)
[](https://github.com/ringcrl/node-point)
[小邵教你玩转nodejs之nodejs概念、事件环机制（1）](https://juejin.cn/post/6844903685605031943)
[大公司里怎样开发和部署前端代码？](https://www.zhihu.com/question/20790576)
[静态资源缓存控制编译工具](https://github.com/fouber/static-resource-digest-project)
[个人博客: 前端工程化](https://github.com/fouber/blog)
[前端工程——基础篇](https://github.com/fouber/blog/issues/10)