# 函数表达式

## 递归

`arguments.callee` 是一个指向正在执行的函数的指针

## 闭包

指有权访问另一个函数作用域中的变量的函数。

作用域的本质是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。
一般来说，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是闭包情况不同
闭包中，内部函数将会包含函数（即外部函数）的活动对象添加到它的作用域链中。 当外部函数执行完毕，其活动对象也不会被销会，因为匿名函数的作用域链仍然引用这个活动对象（即执行环境的作用域链被销毁，但它的活动对象仍然会留在内存中）。

如何清除： 将对该匿名函数的引用设置为null来清除
比如 var a = b(); // 此时a是对内部return的匿名函数的引用
var result = a (xx,xx); // 调用了该匿名函数，获取最终的值
a = null; // 解除a 对匿名函数的引用（来释放内存）

闭包所保存的是整个变量对象，而不是某个特殊的变量

```js
function test () {
    var result = new Array();
    for (var i = 0 ; i < 10 ; i++) {
        result[i] = function() {
            return i;
        }
    }
    return result;
}
// 此时的 result是一个函数数组，但是 里面每个运行都是10
```

因为 每个函数都引用着保存变量i的同一个变量对象，所以在每个函数内部的i的值都是10。

```js
function test2 () {
    var result = new Array();
    for (var i = 0 ; i < 10 ; i++) {
        result[i] = function(t) {
            return function() {
                return t
            }
        }(i)
    }
    return result;
}
```

但是我们可以通过创建另外一个匿名函数强制让闭包的行为符合预期，改进版本中通过定义匿名函数，并将立即执行该函数的结果赋值给数组， 在执行匿名函数时，传入了i，由于函数内部参数是按值传递的，所以会将变量i当前值赋值给参数t，这样就使得每个函数都有自己的t变量的副本
