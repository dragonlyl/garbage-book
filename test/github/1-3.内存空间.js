// https://github.com/yygmind/blog/issues/14

// 无限递归会超出调用堆栈的实际大小

// 堆数据结构
// 堆数据结构是一种树状结构。它的存取数据的方式与书架和书非常相似。我们只需要知道书的名字就可以直接取出书了，
// 并不需要把上面的书取出来。JSON格式的数据中，我们存储的key-value可以是无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。

// js 数据类型  字符串、数字、布尔、数组、对象、Null、Undefined
// 1.基本类型 --> 保存在栈内存中，因为这些类型在内存中分别占有固定大小的空间，通过按值来访问。
//     基本类型一共有6种：Undefined、Null、Boolean、Number 、String和Symbol
// 2、引用类型 --> 保存在堆内存中，因为这种值的大小不固定，因此不能把它们保存到栈内存中，
//     但内存地址大小的固定的，因此保存在堆内存中，在栈内存中存放的只是该对象的访问地址。
//     当查询引用类型的变量时， 先从栈中读取内存地址， 然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问。

// 在计算机的数据结构中，栈比堆的运算速度快，
//     Object是一个复杂的结构且可以扩展：数组可扩充，对象可添加属性，都可以增删改查。
//     将他们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象再进行操作。
//     所以查找引用类型值的时候先去栈查找再去堆查找。


// 内存空间管理

// JavaScript的内存生命周期是
    // 1、分配你所需要的内存
    // 2、使用分配到的内存（读、写）
    // 3、不需要时将其释放、归还

// JavaScript有自动垃圾收集机制，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，
//     使用a = null其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，
//     这个值会在下一次垃圾收集器执行操作时被找到并释放。

// 在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，
//     因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，
//     因此在开发中，需要尽量避免使用全局变量。


var a = {n: 1};
var b = a;
a.x = a = {n: 2};

a.x 	// 这时 a.x 的值是多少
b.x 	// 这时 b.x 的值是多少
// http://www.cnblogs.com/vajoy/p/3703859.html
// 我们知道js的赋值运算顺序永远都是从右往左的，
//     不过由于“.”是优先级最高的运算符，所以这行代码先“计算”了a.x。
// 即 a和b都指向 对象A ,然后 先执行a.x给 对象A添加了属性x 此时的a.x还是代表对象A.x 不过值是undefined
// 然后  从右往左  , a指向变成 对象B了  ;最后指定 a.x = a; 即 A.x = B; 因为 b一直是指向A  所以
// b.x = {n:2}; a = {n:2}; a.x = undefined;