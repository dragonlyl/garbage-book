# 总结

## 待准备

深拷贝函数
缓存机制在背背(浏览器缓存机制.md 的链接)
h5 性能优化打不开
数组乱系+ from 打不开
正则需要准备一下
vue初探-组件化 自定义组件
各个创建模式

## 已准备

### 掘金目录

#### js理论

1. 堆栈内存
2. 浏览器缓存(缓存位置(Service Worker, **memory cache 不是cache memory**, **dist cache 不是disk memory**, **push memory不是hash**), 缓存策略(强缓存(**Cache control, Expire比较老**),协商缓存( **last modified  if modified since** Etag if none match)))
3. 浏览器原理 (页面渲染, 重绘重排,如何避免 用class来一次性修改元素内容 documentFragment,transform替代)
4. 内存泄漏 (如何回收,产生泄漏(意外的全局,dom节点,**遗忘的定时器和回调函数**,闭包).解决: 即使清除引用,减少不必要的全局)
5. event looper 事件循环
event looper (执行栈/调用堆栈 [js engine] 和事件队列 [web Api]) ,异步任务也分 微任务(Promise)和宏任务(setTimeout) 有微任务队列有任务先全部执行完之后再从宏任务取出第一个执行
6. html页面渲染

#### js代码

1. 函数组合(compose: 从右到左调用方法)
2. 柯里化 (curry: 可以接受多个不定量的入参, 场景:参数复用(检测邮箱和手机))

### garbagebook

几大基本数据类型用typeof,除了null返回"object"(认为空指针引用),其他都是自己类型的字符本身

0.1 + 0.2 转换为2进制进行相加 (根源是十进制小数转为二进制小数的过程中，会损失精度)
0.5 => 0.1 (0.5*2 = 1)
0.1 => 0.00011xx( 0.1*2 = 0.2 0.2*2=0.4 0.4*2 = 0.8 0.8*2 =1.6 0.6*2 = 1.2)

arguments对象还有一个callee的属性, 指向拥有这个arguments对象的函数

```js
// 自乘
// 使用callee 这样写的好处在于 你如果改变了函数名并不会对内部调用有影响
function aa(num) {
    if(num <= 1) {
        return 1;
    } else {
        return num * arguments.callee(num - 1);
    }
}
```

内置对象 encodeURI 和encodeURIComponent()
前者只对空格(可以用于整个url),后者对url后面的所有字符,所有后者更常用