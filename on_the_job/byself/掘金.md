# 掘金收集

## js

### 函数形参技巧

形参的时候不一定一个一个声明 `function a (name, job){}`
可以传递一个对象  

```js
function a ({name, job}) {
    console.log(name, job)
}
let jack = {name: 'jack', job: 'delivery'};
a(jack);
a.length; // 可以获取函数接受几个形参
// 来自于小程序
export const getCaseList = ({ searchKeyword, current, size, operateType, caseStatus }) => {
  const data = {
    searchKeyword,
    current,
    size,
    operateType,
    caseStatus
  }
  return request.request({
    url: '/caseEnforce/app/list',
    method: 'post',
    data
  })
}
```

### 监听页面刷新关闭

<https://blog.csdn.net/weixin_34346099/article/details/93176285?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param>
用destroy()方法无法监听到页面刷新和关闭的操作,同时js里面有自带的方法

页面加载时只执行 onload 事件。
页面关闭时，先 onbeforeunload 事件，再 onunload 事件。
页面刷新时先执行 onbeforeunload事件，然后 onunload 事件，最后 onload 事件。

说明: $destroy只是完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。
<https://segmentfault.com/q/1010000011521940>

#### Vue中监听页面刷新和关闭

```js
1. 在methods中定义事件方法：

methods: {
  beforeunloadFn(e) {
    console.log('刷新或关闭')
    // ...
  }
}

2. 在created 或者 mounted 生命周期钩子中绑定事件

created() {
    window.addEventListener('beforeunload', e => this.beforeunloadFn(e))
}

3. 在 destroyed 钩子中卸载事件

destroyed() {
    window.removeEventListener('beforeunload', e => this.beforeunloadFn(e))
}
```

可以用上面的方法在页面离开的时候将购物车的数据提交到服务器

```js

created() {
    this.initCart()
    window.addEventListener('beforeunload', this.updateHandler)
},
beforeDestroy() {
    this.finalCart() // 提交购物车的异步操作},
destroyed() {
    window.removeEventListener('beforeunload', this.updateHandler)
},
methods: {
    updateHandler() {
        this.finalCart()
    },
    finalCart() {
        // ...
    }
}
```

### 惰性函数

表示函数执行的分支只会在函数第一次调用的时候执行。后续我们所使用的就是这个函数执行的结果。

```js
function addEvent(element, type, handler) {
  if (window.addEventListener) {
    element.addEventListener(type, handler, false);
  } else if (window.attachEvent){
    element.attachEvent('on' + type, handler);
  } else {
    element['on' + type] = handler;
  }
}
// 采用惰性函数
function addEvent(element, type, handler) {
  if (window.addEventListener) {
    addEvent = function(element, type, handler) {
      element.addEventListener(type, handler, false);
    }
  } else if (window.attachEvent){
    addEvent = function(element, type, handler) {
      element.attachEvent('on' + type, handler);
    }
  } else {
    addEvent = function(element, type, handler) {
      element['on' + type] = handler;
    }
  }
  addEvent(element, type, handler);
}

```

第一次调用addEvent会对浏览器做能力检测，然后，重写了addEvent。下次再调用的时候，由于函数被重写，不会再做能力检测。

### postcss-px-to-viewport

设置适配，不需要改动代码
<https://juejin.im/post/6867874227832225805>

### map的使用

hash表建议用Map代替object， 有size属性
<https://juejin.im/post/6868115010913550349>
循环 for (let [key, value] of map) { console.log(`${key} = ${value}`); }， map的key的顺序是有序的； map上面的key不会和原型链上的重名（toString也没有，用object.create(null)可以创建一个空的object

## 常识

### ping不通google

<https://www.cnblogs.com/unixcs/p/11274435.html>
我们之所以能够访问google是使用web通过http协议应用层(第七层)
ssr的socks代理是介于传输层(第四层)和会话层(第五层)
而我们在ping的时候，则是基于网络层(第三层)

众所周知：上一层协议的代理 对下层没有任何作用~

## 软件未接触

Nuxt.js vue轻量级应用框架，用来创建服务器渲染ssr应用

## 封装vue

封装vue，发布
<https://juejin.im/post/6867798692460494861>

## nginx

80现在被apache占用
详细配置文件在备忘录 苹果自带apache
重启 nginx -s reload
检测配置 nginx -t
现在配置的端口有 8999
9000 用于指定桌面的tt.html文件
nginx配置文件在 ~/usr/local/etc/nginx
root文件在 ~/usr/local/var/www
cd ~ 表示进入系统中home目录，一般就是你的root权限目录 ；cd / 表示进入系统的根目录，最顶层目录 

## css

`white-space: pre-line;`// 每个回车键换行

## 英语

stun 眩晕
nutshell 坚果
avid 热衷的
clutch time 生死时刻