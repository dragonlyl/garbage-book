# 写法优化

## 函数形参技巧

形参的时候不一定一个一个声明 `function a (name, job){}`
可以传递一个对象  

```js
function a ({name, job}) {
    console.log(name, job)
}
let jack = {name: 'jack', job: 'delivery'};
a(jack);
a.length; // 可以获取函数接受几个形参
// 来自于小程序
export const getCaseList = ({ searchKeyword, current, size, operateType, caseStatus }) => {
  const data = {
    searchKeyword,
    current,
    size,
    operateType,
    caseStatus
  }
  return request.request({
    url: '/caseEnforce/app/list',
    method: 'post',
    data
  })
}
```

## 惰性函数

表示函数执行的分支只会在函数第一次调用的时候执行。后续我们所使用的就是这个函数执行的结果。

```js
function addEvent(element, type, handler) {
  if (window.addEventListener) {
    element.addEventListener(type, handler, false);
  } else if (window.attachEvent){
    element.attachEvent('on' + type, handler);
  } else {
    element['on' + type] = handler;
  }
}
// 采用惰性函数
function addEvent(element, type, handler) {
  if (window.addEventListener) {
    addEvent = function(element, type, handler) {
      element.addEventListener(type, handler, false);
    }
  } else if (window.attachEvent){
    addEvent = function(element, type, handler) {
      element.attachEvent('on' + type, handler);
    }
  } else {
    addEvent = function(element, type, handler) {
      element['on' + type] = handler;
    }
  }
  addEvent(element, type, handler);
}

```

第一次调用addEvent会对浏览器做能力检测，然后，重写了addEvent。下次再调用的时候，由于函数被重写，不会再做能力检测。