# 正则(重要)

<https://regexr.com/>

## 点运算符

. 在里面匹配一个任意字符(不能匹配换行)

1. 用在 .an 这时候就能匹配can van这些字母
2. \. 和 [.]两者的作用是一样的

## 字符集

[ab] 匹配括号里面的一个字符(括号里字符是并的关系)
例如 [cv]an 用来匹配 can 或 van

### 否定字符集

[^ab] 匹配除里面字符除外的字符

[a-g] 匹配字符在a~g的一个字符

## 重复次数

*大于等于0
即 er后面跟* 会有只有e的情况被筛选出来

+大于等于1

？可以使标记前面的字符变成0/1次
搭配* 和 +可以使匹配变成非贪婪

## {} 量词

里面可以写前一个字符具体可以出现多少次

[0-9]{2,3} 匹配最少 2 位最多 3 位 0~9 的数字。
{0,} 表示 *
{1,} 表示 +
{0,1} 表示 ？
这里也可以和？搭配，让匹配不贪婪

## （）特征标群

() 中用或字符 | 表示或
(ab) 捕获ab 类似ab
(a|b) 捕获a或b 类似 {ab} // 这里是惰性匹配
例如 goodbye 用(good|goodbye) ，那么遇到good就不会再去匹配goodbye了

## | 或运算符

(T|t)he|car 匹配 (T|t)he 或 car。
而不是 (T|t)he 或 (T|t)car。

## 特殊转码

`{ } [ ] / \ + * . $ ^ | ?`这些的里面有特殊用途 需要用`\`来转义才能匹配

## 锚点^ 指定开头，$ 指定结尾

## 简写字符集

\w \d \s
全部字符（不包括标点符号）[a-zA-Z0-9_]
全部数字 [0-9]
全部空格

\W \D \S
大写表示非

所以匹配任意字符写法： [\d\D],[\w\W],[\s\S]

\n 换行
\r 回车

## 零宽度断言（前后预查）

?= 正先行断言-存在
?! 负先行断言-排除
?<= 正后发断言-存在
?<! 负后发断言-排除

自己写的匹配a标签的href
// 不能排除href后面跟着其他属性情况
// 需要最后再用split(\["']\)来排除
(?<=\<a.+href\s*=\s*["|']).+(?=["|'].*>[^>]*</a>)
// 链接有冒号就有问题了
(?<=\<a.+href\s*=\s*["|'])[^"']+

自己写的24小时匹配
/^([01][0-9]|2[0-3]):[0-5][0-9]$/

自己写的 yyyy-mm-dd
/^[0-9]{4}-0[1-9]|[1][0-2]-0[1-9]|[1-2][0-9]|[3][01]/

## 拓展 位置匹配攻略

<<https://juejin.im/post/5965943ff265da6c3065387>

### ES5有6个锚字符

> `^ $ \b \B (?=p) (?!p)`

例如 'hello'.replace(/^|$/g,'#');
最后会变成 #hello#

\b是单词边界 具体是\w和\W之间的位置也包括\w和^$之间的位置
"[JS] Lesson_01.mp4".replace(/\b/g, '#')
// => "[#JS#] #Lesson_01#.#mp4#" 结果

\B 跟上面的结果相反
// #[J#S]# L#e#s#s#o#n#_#0#1.m#p#4

#### 数字的千位符

'1234567'.replace(/(?!^)(?=(\d{3})+$)/g,',')

[正则实现数字的千位分隔符表示法](https://www.cnblogs.com/yalong/p/15183715.html)

简单说明:

1. ?=n 匹配任何其后紧接指定字符串 n 的字符串。
2. ?!n 匹配任何其后没有紧接指定字符串 n 的字符串。

```js
(?=\d{3}$) // 匹配最后一个
(?=\d{3})+$ // 匹配多个 但是会出现逗号为第一个的情况
(?!^) // 排除第一个
```

如果要把"12345678 123456789"替换成"12,345,678 123,456,789"

把^和$换成\b   其实(?!\b)说的就是\B
因此最终正则变成了：/\B(?=(\d{3})+\b)/g

#### 设置密码

密码长度6-12位，由数字、小写字符和大写字母组成，且密码必须包含数字
/(?=.*[0-9])^[0-9A-Za-z]{6,12}$/;

## 括号的使用

### 配合一些方法用来提取数据

***第一个整体匹配结果，然后是各个分组（括号里）匹配的内容。然后是匹配下标，最后是输入的文本***
var regex = /(\d{4})-(\d{2})-(\d{2})/;
var string = "2017-06-12";
console.log( string.match(regex) );
// => ["2017-06-12", "2017", "06", "12", index: 0, input: "2017-06-12"]

同时也可以用 `RegExp.$1` 来拿到第一个括号里面的内容

### 替换格式

string.replace(regex, "$2/$3/$1");

### 反向引用

想匹配这三种
2016-06-12
2016/06/12
2016.06.12
用 `/\d{4}(-|\/|\.)\d{2}(-|\/|\.)\d{2}/` 会匹配到 2016-06/12 这种情况
所以要用到 `\1` 表示引用之前的那个分组，不管匹配到分组的哪一个, \1匹配到的是同样那个字符
`/\d{4}(-|\/|\.)\d{2}\1\d{2}`

#### 反向引用如果括号嵌套怎么办

主要以左括号为准

``` // 第一个括号是一直到最后  第二个括号是就一个d 第三个括号是两个d 最后一个是一个d
var regex = /^((\d)(\d(\d)))\1\2\3\4$/;
var string = "1231231233";
console.log( regex.test(string) ); // true
console.log( RegExp.$1 ); // 123
console.log( RegExp.$2 ); // 1
console.log( RegExp.$3 ); // 23
console.log( RegExp.$4 ); // 3
所以\1\2\3\4对应关系跟括号对应关系一样
```

### 非捕获分组

即我想用括号，但是我括号又不是拿来做捕获用途的 可以用 `(?:p)` 即p如果匹配到了也不会在API也不会在反向引用中

#### 可能用到的正则

##### 将每个单词的首字母转换为大写

// 即开头和每个空格的字母大写
str.toLowerCase().replace(/(?:^|\s)\w/g,(c) => c.toUpperCase());

## 正则的的回溯法原理

说明： /ab{1,3}c/ 正则
用来匹配abbbc 没有回溯
用来匹配abbc 有回溯 即 当判断第三个b的时候遇到了c此时要回溯成2个b以致c能匹配上

***正则引擎有两种DFA和NFA引擎***
这里我没有细看具体分别（懒）

### 正则工具（可视化

<https://regexper.com/>  网络问题
<https://aoxiaoqiang.github.io/reg> （替代上方工具）
<https://jex.im/regulex>

<https://www.debuggex.com>
